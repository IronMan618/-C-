# 树（Tree）

**1.定义**

    树（Tree）是n（n>=0）个节点的有限集合。当n=0时成为空树，在任意一颗非空树上：
    —— 有伽经有一个特定的称之为根（Root）的节点；
    —— 当n>1时，其余节点可分为m个互不相交的有限集T1，T2。。。。。Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）
   ![树的简单结构](/home/gavin/数据结构.c(Github)/树.png "树")

    ——n>0时，根节点是唯一的，坚决不可能存在多个根节点
    ——m>0时，子树的个数是没有限制的，但是他们互相是一定不会相交的

**2.节点的分类**

    ——上面的图片，每一个圈圈我们就成为树的一个节点。节点拥有的子树树称为树的度-（Degree），树的度取树内各节点的最大值。
    ——度为0的节点称为叶节点或者终端节点；
    ——度不为0的节点成为分支节点或者非终端节点，除根节点外，分支节点也称为内部节点。


**3.二叉树的性质**

    ——深度为K的二叉树至多有2^k-1个结点
    ——对于任何一棵二叉树T如果其终端结点数为n0，度巍峨u2的结点数为n2，则n0=n2+1
    ————上式结论推导：首先我们在假设度为n1，则二叉树T的结点总数为n=n0+n1+ n2
    ————其次我们发现连接总数等于总结点数n-1，并且等于n1+2*n2
    ————所以n-1=n1+2*n2
    ————所以n0+n1+n2-1=n1+n2+n2
    ————最后n0=n2+1
    ——具有n个结点的完全二叉树的深度为(log以2为第底n的对数下限取整）+1
    ————由满二叉树的定义结合性质我们知道，深度为k的满二叉树的结点树n一定是2^k-1
    ————那么我们对于满二叉树可以同归n=2^k-1倒推的到满二叉树的深度为(log以2为第底n的对数下限取整）+1
    ——如果一个有n个结点的完全二叉树（其深度为(log以2为第底n的对数下限取整）+1）的结点安层序编号，对于任意结点i（1<=i<=n）有以下性质：
        ->如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲结点是(i/2的下限取整)
        ->如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其做孩子是结点2i

**4.二叉树的存储结构**

    同样有顺序存储结构和链式存储结构，顺序存储结构就是用数组连是存储结构就是构造一个存在两个指针域和一个数据域（指针域存在于数据域的两边）
    链式结构的构造如下：

```c
    typedef struct BiTNode
    {
        ElemType data;
        struct BiTNode *lchild, *rchild;
    }BiTNode, *BiTree;
```

![链式存储二叉树图式](/home/gavin/数据结构.c(Github)/二叉树.png "二叉树")

**5.遍历二叉树：**


    ——>前序遍历：先根节点在左结点在右结点（如上图遍历结果为：abdecfg）
    ——>中序遍历：先左结点在根节点在右结点（如上图遍历结果为：dbeafcg）
    ——>后序遍历：先左结点在右结点在根节点（如上图遍历结果为：debfgca）
    ——>层序遍历：一层一层的往下遍历(如上图遍历结果为：abcdefg)

**6.二叉树的建立和遍历算法**


代码如下：
```c
//题目：
//建立二叉树并输出每个字节所在的层数。

#include <stdio.h>
#include <stdlib.h>
typedef char ElemType;
typedef struct  BiTNode
{
    char data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;

//创建一棵二叉树,
int CreateBiTree(BiTree *T)
{
    char c;
    scanf("%c",&c);
    if(' ' == c)
    {
        *T = NULL;
    }
    else
    {
        *T = malloc(sizeof(BiTNode));
        (*T)->data = c;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);
    }
}

//访问二叉树结点的具体操作
void visit(char c, int level)
{
    printf("%c 位于第%d层\n",c,level);
}

//前序遍历二叉树
void PreOrderTraverse(BiTree T, int level)
{
    if(T)
    {
        visit(T->data, level);
        PreOrderTraverse(T->lchild, level+1);
        PreOrderTraverse(T->rchild, level+1);
    }
}

int main()
{
    int level = 1;
    BiTree T = NULL;

    CreateBiTree(&T);
    PreOrderTraverse(T, level);

    return 0;

}
```    
输入：
```
    (abd  e  cf  g  )
```
输出则为上文的二叉树，结果为：
```
    a 位于第1层
    b 位于第2层
    d 位于第3层
    e 位于第3层
    c 位于第2层
    f 位于第3层
    g 位于第3层
```
**注意：**按照结果和对应的前序遍历的顺序就可以画出上文的二叉树。


**7.线索二叉树：**

线索二叉树不同于上面的二叉树，上面的代码使用单链表结合前序遍历的方式实现的，缺点很明显就是有很多NULL的结点占空间，并且只能够单向：a->b可以代是b不能->a。因此在线索二叉树中重新构造每个节点，之前的节点构造是一个数据域两边各一个指针域，而在这里构造的结点是 ：中间任然是数据域，但是两边（紧贴在数据域的两边）是两个判断域，此外边的两个是指针域如下图：

![线索二叉树](/home/gavin/数据结构.c(Github)/线索二叉树.png "线索二叉树")

当 ltag为0时lchild表示指向下一个左孩结点，当ltag为1时lchild表示指向该节点的前驱。
右边的rtag和rchild同理。

***代码如下：***

```c
    
```
###太难了，停止一下，后续我搞懂了在补上。



**8.树/森林及二叉树的相互转换**

略



**9.赫夫曼树**

//赫夫曼编码是首个实用的压缩编码方案

——我恶魔年先把这两棵二叉树化成叶子结点带权的二叉树（注：树结点之间的连线相关的数值和叫做权Weight）
——结点的路进长度：从根节点到该结点的路径上的连接数
——树的路径长度：数中每个叶子结点的路径长度之和
——结点带权路径长度：结点的路径长度域及结点权值的乘积
——树的带权路径长度：WPL是树中所有节子结点的带权路径长度值和
>WOL越小，说明构造出来的二叉树性能越优。

       **赫夫曼树（最优二叉树）的构造方法**
           ->简单的来讲就是从最小的一层一层的往上建造：
           例如：初始化A（7）， B（5）， C（4）， D（2）  //【data(weight)】
           首先选出两个最小的weight的结点小的放左面大的在有面,并且虚构一个结点其weight为孩子的weight的和：
                                [虚构]（6）
                               /        \   
                             D(2)       C(4)
           然后在选出一个次小的与虚构的比较如果<[虚构](weight)放左边反之右边，然后再建立一个虚构结点：
                                [虚构]（11）
                               /         \
                             B(5)     [虚构]（6）
                                     /        \
                                   D(2)       C(4)
           同理：
                                [虚构]（18）
                               /          \
                             A(7)       [虚构](11)
                                       /         \
                                     B(5)       [虚构](6)
                                               /        \
                                             D(2)       C(4)
>           ****由此可的树的最优二叉树为上面，WPL最小****

**10.赫夫曼编码：**

——名词解释：

————>定长编码：像ASCII编码（每一个要8位）

————>变长编码：单个编码的长度不一致，可根据整体出现频率来调节（约定好规则，用小的代替大的）

————>前缀码： 所谓的前缀码，就是没有任何码字的前缀

****实现代码：****
```
    首先思路理清：有下面的组件组成
    -build a priority queue       ----创建队列，具有优先级的多列，优先级取决于字符在文本中出现的次数，出现的次数越多权值越高，位于树的位置越靠前
    -build a huffmanTree          ----采用】上问题到的方法**赫夫曼树的构造方法
    -build a huffmanTable         ----创建一个赫夫曼表，存放赫夫曼的编码（左子树都用0表示，右子树都有1表示）
    -encode                       ----在一次遍历要压缩的文件，找到到对应的字符（根据赫曼弗树的表格），并且把对应的编码打印出来，写入另一个文件
    -decode                       ----解码过程 = 从根出发，如果拿到的赫夫曼（由上面解码文件后所构成的赫夫曼树）字符为0的话往左边走一下，为1的花往右边走一下。最后找到叶子并且把叶子的编码显示出来。
```
![HeffmanTree](https://www.cs.princeton.edu/courses/archive/spr07/cos226/assignments/huffman.png)


节点（左右）的权值之和是等于双亲的权并且结点的权值是字符出现的次数
> 代码实现：
```c
略

```














